# lab2-TIDI25

Idea: 
бильярд где шары могут притягиваться/отталкиваться или бильярд со крайне тяжелыми шарами (возможно с планетами солнечной системы, тогда это 9-ball)
 -
шаг 0. написать обычную 9-ball версию, соответственно:
---


что-то в логике игры

структура/класс шар{    
скорость    
x   
y   
радиус  
//масса или заряд (вот зачем вы проверяете readme в коммитах?)  
флаг //на случай если если шар черный или если шар белый (возможно enum или поле с цветом)  
}

что-нибудь для кия{     
начальное положение (x,y)   
конечное положение (x,y)    
}

расчет скорости кия //дельта x и дельта y

передача импульса от кия к белому шару //записываем дельта х и дельта у в скорость шара

обновление скорости шаров при столкновение друг с другом //что-то с углами и импульсами 

стол{   
x,y середины или угла   
x,y длинны/2 или второго угла   
коэффициент  трения (что бы шары не катались бесконечно)    
}

функция расчета конечной точки (т.е. скорость шара падает со временем из-за трения)

---

время? нужно ли мне время? если да, то делаю ли я его привязанным к кадрам анимации? наверное, время нужно, но привязанное не к анимации

---
шаг (-1) - разобраться со следующим бредом:
---
что-то вне класса   
обновление //я не хочу пихать это в класс с логикой игры, при этом я делаю обновление через интерфейс 

значит я где-то в отдельном файле для расчета анимации храню текущий шаг анимации, список объектов для которых нужно изменить x и y        
//звучит плохо, мало того что я храню текущий шаг анимации, так ещё x, y, шаг по x, шаг по y для каждого объекта анимации; стоит обойтись как-то только шагом анимации 

---
контроллер 

1) понять где тут начало, а где конец координат (вдруг эту библиотеку запускает в на чем-то где 0, 0 это центр или левый нижний угол или правый верхний, моя библиотека вообще хз кто и где её запускает) //инициализация 


---
интерфейс 
- IUpdate
- какие-то флаги общие для класса и анимации 

---
шаг 1 - исправить архитектуру проекта
---
шаг 2 - узнать а стоит ли использовать readme для планирования шагов (нет. но ручку и бумагу я доставать не хочу)
---
шаг 3 - всмонить о сроках сдачи, забыть про идею, оставить 9-ball с багами 
---

![lab2.png](diagrams/lab2.png)
---
ТЗ:
1. Реализовать игру, например клеточный автомат "Игра Жизнь"

2. Обязательные технические требования (C++)
Код должен демонстрировать владение принципами ООП. Для этого необходимо реализовать:
- Интерфейсы: В программе должен быть минимум один абстрактный класс (чисто виртуальные методы).
- Наследование: Должна быть реализована иерархия классов (наследники реализуют интерфейс).
- Перегрузка: Использовать перегрузку методов или операторов (например, оператор вывода << или индексации []).
- Управление памятью: Использовать умные указатели (std::unique_ptr, std::shared_ptr). "Сырые" указатели (new/delete) для владения ресурсами запрещены.

3. Дополнительные требования (для получения высокого балла)
- Полиморфизм (Пункт 4): Написать функцию или метод, которая принимает на вход объект через интерфейс (базовый класс), но корректно работает с передаваемым ей экземпляром конкретного класса-наследника.
- Связка C++ и Python (Пункт 5):
— Логика игры пишется на C++.
— Код компилируется в динамическую библиотеку (.so файл).
— Используется библиотека pybind11 для создания обертки (wrapper).
— Результат: модуль импортируется в Python, где происходит запуск или визуализация. Графику на самом C++ в этом случае делать не нужно.
- Документация (Пункт 7): Нарисовать схему архитектуры классов (например, в draw.io).


