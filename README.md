# lab2-TIDI25

Idea: 
бильярд где шары могут притягиваться/отталкиваться или бильярд со крайне тяжелыми шарами (возможно с планетами солнечной системы, тогда это 9-ball)
 -
шаг 0. написать обычную 9-ball версию, соответственно:
---


что-то в логике игры

структура/класс шар{    
скорость    
x   
y   
радиус  
//масса или заряд (вот зачем вы проверяете readme в коммитах?)  
флаг //на случай если если шар черный или если шар белый (возможно enum или поле с цветом)  
}


кий {   
    начальное положение (x,y)  
    направление (вектор)    
    сила удара  
    }

расчет скорости кия //дельта x и дельта y

передача импульса от кия к белому шару //записываем дельта х и дельта у в скорость шара

обновление скорости шаров при столкновение друг с другом //что-то с углами и импульсами 

стол{   
x,y середины или угла   
x,y длинны/2 или второго угла   
коэффициент  трения (что бы шары не катались бесконечно)    
}

функция расчета конечной точки (т.е. скорость шара падает со временем из-за трения)

---

время? нужно ли мне время? если да, то делаю ли я его привязанным к кадрам анимации? наверное, время нужно, но привязанное не к анимации

обновление //все ещё не ясно зависит ли оно от времени или от кадров анимации   
скорее всего это все будет в пределах основного класса, где питон вместо времени отдает обновление экрана 

т.е.    
#где-то в main.py
FPS = 60 //или get_FPS_from_system
game = New Game(FPS)

//где-то в контроллере в C++
set animation_step = FPS

#где-то в main.py привязать update к обновлению экрана 
---
контроллер 

1) понять где тут начало, а где конец координат (вдруг эту библиотеку запускает в на чем-то где 0, 0 это центр или левый нижний угол или правый верхний, моя библиотека вообще хз кто и где её запускает) 

инициализация //определить единую систему координат для всего проекта

2. start/reset
3. Is everyting OK? //проверка границ, стоконовений, выброс исключений и прочие методы
4. What should I do? (какие-то параметры которые передал нам питон) -> вызов чего-нибудь из основного класса // методы обработки пользовательского ввода/действий
5. I guessos all good //вернуть питону объекты класса через get которые он попросил (а судя по pygame он просит все, т.ч. этот метод будет возвращать список из всех шаров, кия и стола)

//на случай если у нас будет не pygame - вернуть список не всех эллементов, а только шаров, только кия или только стола (+ 3 ф-ии)

---
интерфейс 
- IUpdate //попросить класс обновить все на один шаг
- IRenderable //крассивое название для I guessos all good, т.е. get_список_всех_эллементов

IGameController{    
I_все_методы_контроллера //для того что бы питон знал об их существовании и мог вызвать     
}

---
шаг 1 - исправить архитектуру проекта
---
шаг 2 - узнать а стоит ли использовать readme для планирования шагов (нет. но ручку и бумагу я доставать не хочу)
---
шаг 3 - всмонить о сроках сдачи, забыть про идею, оставить 9-ball с багами 
---

![lab2.png](diagrams/lab2.png)
---
ТЗ:
1. Реализовать игру, например клеточный автомат "Игра Жизнь"

2. Обязательные технические требования (C++)
Код должен демонстрировать владение принципами ООП. Для этого необходимо реализовать:
- Интерфейсы: В программе должен быть минимум один абстрактный класс (чисто виртуальные методы).
- Наследование: Должна быть реализована иерархия классов (наследники реализуют интерфейс).
- Перегрузка: Использовать перегрузку методов или операторов (например, оператор вывода << или индексации []).
- Управление памятью: Использовать умные указатели (std::unique_ptr, std::shared_ptr). "Сырые" указатели (new/delete) для владения ресурсами запрещены.

3. Дополнительные требования (для получения высокого балла)
- Полиморфизм (Пункт 4): Написать функцию или метод, которая принимает на вход объект через интерфейс (базовый класс), но корректно работает с передаваемым ей экземпляром конкретного класса-наследника.
- Связка C++ и Python (Пункт 5):
— Логика игры пишется на C++.
— Код компилируется в динамическую библиотеку (.so файл).
— Используется библиотека pybind11 для создания обертки (wrapper).
— Результат: модуль импортируется в Python, где происходит запуск или визуализация. Графику на самом C++ в этом случае делать не нужно.
- Документация (Пункт 7): Нарисовать схему архитектуры классов (например, в draw.io).


